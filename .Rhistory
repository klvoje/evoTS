if (is.numeric(vo) == TRUE) vo<-vo else vo <- opt.joint.OU.BM(y)$parameters[4]
loglik<-matrix(NA, ncol=length(stat.var.vec), nrow=length(h.vec))
stat.var.limit<-rep(NA, length(stat.var.vec))
h.limit<-rep(NA, length(h.vec))
i<-1
j<-1
aa <- log(2)/h.vec[j]
vs <- stat.var.vec[i]*2*aa
aa
vs
ff <- function(a, b) abs(a - b)
tij<-outer(y$tt, y$tt, FUN = ff)
ta<-outer(y$tt, y$tt, pmin)
VCOV<- ((vo+vs)/(2 * aa)) * (1 - exp(-2 * aa * ta)) * exp(-aa *tij) + (vo*ta*(1-((1+exp(-aa*tij))*(1-exp(-aa*ta))/(aa*ta))))
VCOV[1,]<-0;
VCOV[,1]<-0;
diag(VCOV) <- diag(VCOV) + y$vv/y$nn
theta<-rep(theta.0, n)
theta
VCOV
M <- ou.M(anc, theta, aa, x$tt)
mvtnorm::dmvnorm(t(y$mm), mean = M, sigma = VCOV, log = TRUE)
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.OUBM.R")
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,0.5,0.1), h.vec=seq(0.0001,1, 0.1))
?mvtnorm::dmvnorm
x <- paleoTS::sim.GRW(50)
## Fit a the model to the data by defining shift points.
x1<-fit.Bokma(x, minb=10)
v_1<-seq(0,1,0.01)
v_2<-seq(0,1, 0.01)
##Compute likelihood surface
loglik.surface.Bokma(x, vstep_1.vec=v_1, vstep_2.vec=v_2, shift=11, anc=0.4280, new.opt=1.7025)
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.OUBM.R")
x <- paleoTS::sim.OU(40)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.OU(x)
##calculate half-life from model output
log(2)/x1$parameters[4]
##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[4])
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,0.5,0.1), h.vec=seq(0.0001,1, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,0.5,0.1), h.vec=seq(0.01,1, 0.1))
stat.var.vec=seq(0.1,0.5,0.1)
h.vec=seq(0.01,1, 0.1)
x<-NULL
if (min(stat.var.vec)<0) stop("the stationary variance cannot take negative values. The smallest value is 0")
if (min(h.vec)<0) stop("the half-life cannot take negative values. The smallest value is 0")
if (pool)
y <- paleoTS::pool.var(y, ret.paleoTS = TRUE)
y$tt <- y$tt - min(y$tt)
n <- length(y$mm)
if (is.numeric(anc) == TRUE) anc<-anc else anc <- opt.joint.OU.BM(y)$parameters[1]
if (is.numeric(theta.0) == TRUE) theta.0<-theta.0 else theta.0 <- opt.joint.OU.BM(y)$parameters[3]
if (is.numeric(vo) == TRUE) vo<-vo else vo <- opt.joint.OU.BM(y)$parameters[4]
loglik<-matrix(NA, ncol=length(stat.var.vec), nrow=length(h.vec))
stat.var.limit<-rep(NA, length(stat.var.vec))
h.limit<-rep(NA, length(h.vec))
for (i in 1:length(stat.var.vec)){
for (j in 1:length(h.vec)){
aa <- log(2)/h.vec[j]
vs <- stat.var.vec[i]*2*aa
ff <- function(a, b) abs(a - b)
tij<-outer(y$tt, y$tt, FUN = ff)
ta<-outer(y$tt, y$tt, pmin)
VCOV<- ((vo+vs)/(2 * aa)) * (1 - exp(-2 * aa * ta)) * exp(-aa *tij) + (vo*ta*(1-((1+exp(-aa*tij))*(1-exp(-aa*ta))/(aa*ta))))
VCOV[1,]<-0;
VCOV[,1]<-0;
diag(VCOV) <- diag(VCOV) + y$vv/y$nn
theta<-rep(theta.0, n)
M <- ou.M(anc, theta, aa, x$tt)
loglik[j,i] <- mvtnorm::dmvnorm(y$mm, mean = M, sigma = VCOV, log = TRUE)
print(i)
print(j)
}
}
for (i in 1:length(stat.var.vec)){
for (j in 1:length(h.vec)){
aa <- log(2)/h.vec[j]
vs <- stat.var.vec[i]*2*aa
ff <- function(a, b) abs(a - b)
tij<-outer(y$tt, y$tt, FUN = ff)
ta<-outer(y$tt, y$tt, pmin)
VCOV<- ((vo+vs)/(2 * aa)) * (1 - exp(-2 * aa * ta)) * exp(-aa *tij) + (vo*ta*(1-((1+exp(-aa*tij))*(1-exp(-aa*ta))/(aa*ta))))
VCOV[1,]<-0;
VCOV[,1]<-0;
diag(VCOV) <- diag(VCOV) + y$vv/y$nn
theta<-rep(theta.0, n)
M <- ou.M(anc, theta, aa, x$tt)
print(i)
print(j)
loglik[j,i] <- mvtnorm::dmvnorm(y$mm, mean = M, sigma = VCOV, log = TRUE)
}
}
i
j
mvtnorm::dmvnorm(y$mm, mean = M, sigma = VCOV, log = TRUE)
M
M <- ou.M(anc, theta, aa, x$tt)
M
ou.M
aa
vs
tij
ta
VCOV
VCOV
VCOV
diag
theta
diag(VCOV)
M <- ou.M(anc, theta, aa, x$tt)
ou.M(anc, theta, aa, x$tt)
anc
theta
aa
x$tt
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.OUBM.R")
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,0.5,0.1), h.vec=seq(0.01,1, 0.1))
x<-NULL
if (min(stat.var.vec)<0) stop("the stationary variance cannot take negative values. The smallest value is 0")
if (min(h.vec)<0) stop("the half-life cannot take negative values. The smallest value is 0")
if (pool)
y <- paleoTS::pool.var(y, ret.paleoTS = TRUE)
y$tt <- y$tt - min(y$tt)
n <- length(y$mm)
if (is.numeric(anc) == TRUE) anc<-anc else anc <- opt.joint.OU.BM(y)$parameters[1]
if (is.numeric(theta.0) == TRUE) theta.0<-theta.0 else theta.0 <- opt.joint.OU.BM(y)$parameters[3]
if (is.numeric(vo) == TRUE) vo<-vo else vo <- opt.joint.OU.BM(y)$parameters[4]
loglik<-matrix(NA, ncol=length(stat.var.vec), nrow=length(h.vec))
stat.var.limit<-rep(NA, length(stat.var.vec))
h.limit<-rep(NA, length(h.vec))
aa <- log(2)/h.vec[j]
vs <- stat.var.vec[i]*2*aa
ff <- function(a, b) abs(a - b)
tij<-outer(y$tt, y$tt, FUN = ff)
ta<-outer(y$tt, y$tt, pmin)
VCOV<- ((vo+vs)/(2 * aa)) * (1 - exp(-2 * aa * ta)) * exp(-aa *tij) + (vo*ta*(1-((1+exp(-aa*tij))*(1-exp(-aa*ta))/(aa*ta))))
VCOV[1,]<-0;
VCOV[,1]<-0;
diag(VCOV) <- diag(VCOV) + y$vv/y$nn
theta<-rep(theta.0, n)
M <- ou.M(anc, theta, aa, y$tt)
print(i)
print(j)
mvtnorm::dmvnorm(y$mm, mean = M, sigma = VCOV, log = TRUE)
x <- paleoTS::sim.OU(40)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.OU(x)
##calculate half-life from model output
log(2)/x1$parameters[4]
##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[4])
##Compute likelihood surface
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,0.5,0.1), h.vec=seq(0.01,1, 0.1))
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.OUBM.R")
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,1,0.1), h.vec=seq(0.01,1, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0.1,5,0.1), h.vec=seq(0.01,1, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.1), h.vec=seq(0.01,2, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.1), h.vec=seq(0.0,2, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.01), h.vec=seq(0.0,1.5, 0.1))
rm(loglik.surface.OUBM)
detach("package:evoTS", unload = TRUE)
document()
check()
library(evoTS)
x <- paleoTS::sim.GRW(30)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.URW(x)
##Compute likelihood surface
loglik.surface.URW(x, vstep.vec = seq(0,0.3,0.001))
x
x$mm[1]
x <- paleoTS::sim.GRW(30)
x1<-paleoTS::opt.joint.URW(x)
loglik.surface.URW(x, vstep.vec = seq(0,0.3,0.001))
vstep.vec = seq(0,0.3,0.001)
if (min(vstep.vec)<0) stop("the vstep parameter cannot take negative values. The smallest value is 0")
y <- paleoTS::pool.var(y, ret.paleoTS = TRUE)
y$tt <- y$tt - min(y$tt)
n <- length(y$mm)
anc<-paleoTS::opt.joint.URW(y)$parameters[1]
loglik<-rep(NA, length(vstep.vec))
vstep.limit<-rep(NA, length(vstep.vec))
i
vstep <- vstep.vec[i]
VV <- vstep * outer(y$tt, y$tt, FUN = pmin)
diag(VV) <- diag(VV) + y$vv/y$nn
M <- rep(anc, n)
mvtnorm::dmvnorm(y$mm, mean = M, sigma = VV, log = TRUE)
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.URW.R")
loglik.surface.URW(x, vstep.vec = seq(0,0.3,0.001))
rm(loglik.surface.URW)
x <- paleoTS::sim.Stasis(30)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.Stasis(x)
##Compute likelihood surface
loglik.surface.stasis(x, theta.vec= seq(-0.15,0.1,0.001), omega.vec = seq(0,0.1,0.001))
theta.vec= seq(-0.15,0.1,0.001)
omega.vec = seq(0,0.1,0.001)
if (min(omega.vec)<0) stop("the omega parameter cannot take negative values. The smallest value is 0")
if (pool)
y <- paleoTS::pool.var(y, ret.paleoTS = TRUE)
y$tt <- y$tt - min(y$tt)
n <- length(y$mm)
loglik<-matrix(NA, ncol=length(theta.vec), nrow=length(omega.vec))
theta.limit<-rep(NA, length(theta.vec))
omega.limit<-rep(NA, length(omega.vec))
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.stasis.R")
loglik.surface.stasis(x, theta.vec= seq(-0.15,0.1,0.001), omega.vec = seq(0,0.1,0.001))
rm(loglik.surface.stasis)
document()
check()
x<-sim.OUBM(50, theta.0 = 5, alpha = 0.6, vstep.opt = 0.5)
documebt()
document()
check()
loglik.surface.accel(x, vstep.vec = seq(0,10,0.1), r.vec = seq(0,0.15,0.001))
x <- paleoTS::sim.GRW(30)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.accel(x)
## Create log-likelihood surface (the example may take > seconds to run)
loglik.surface.accel(x, vstep.vec = seq(0,10,0.1), r.vec = seq(0,0.15,0.001))
x <- paleoTS::sim.GRW(50)
## Fit a the model to the data by defining shift points.
x1<-fit.Bokma(x, minb=10)
v_1<-seq(0,1,0.01)
v_2<-seq(0,1, 0.01)
?sim.Bokma
x <- sim.Bokma()
x
x1<-fit.Bokma(x, minb=10)
x1
v_1<-seq(0,1,0.01)
## loglik.surface.Bokma(x, vstep_1.vec=v_1, vstep_2.vec=v_2, shift=11, anc=0.4280, new.opt=1.7025)
loglik.surface.Bokma(x, vstep_1.vec=v_1, vstep_2.vec=v_2, shift=11, anc=0.4280, new.opt=1.7025)
?sim.accel.decel
x <- sim.accel.decel(50)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.accel(x)
x1
loglik.surface.accel(x, vstep.vec = seq(0,10,0.1), r.vec = seq(0,0.5,0.001))
x <- sim.accel.decel(50)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.accel(x)
loglik.surface.accel(x, vstep.vec = seq(0,10,0.1), r.vec = seq(0,0.5,0.001))
x1
loglik.surface.accel(x, vstep.vec = seq(0,3,0.01), r.vec = seq(0,0.5,0.001))
vstep.vec = seq(0,3,0.01)
r.vec = seq(0,0.5,0.01)
y<-x
if (min(vstep.vec)<0) stop("the variance parameter cannot take negative values. The smallest value is 0")
if (pool)
y <- paleoTS::pool.var(y, ret.paleoTS = TRUE)
y$tt <- y$tt - min(y$tt)
n <- length(y$mm)
anc<-opt.joint.decel(y)$parameters[1]
loglik<-matrix(NA, ncol=length(vstep.vec), nrow=length(r.vec))
vstep.limit<-rep(NA, length(vstep.vec))
r.limit<-rep(NA, length(r.vec))
i
vstep <- vstep.vec[i]
r <- r.vec[j]
VV <- vstep * outer(exp(r*y$tt), exp(r*y$tt), FUN = pmin)
diag(VV) <- diag(VV) + y$vv/y$nn
M <- rep(anc, n)
mvtnorm::dmvnorm(y$mm, mean = M, sigma = VV, log = TRUE)
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.accel.R")
loglik.surface.accel(x, vstep.vec = seq(0,3,0.01), r.vec = seq(0,0.5,0.01))
x1
loglik.surface.accel(x, vstep.vec = seq(0,5,0.01), r.vec = seq(0.15,0.25,0.01))
?opt.joint.accel
loglik.surface.accel(x, vstep.vec = seq(0,5,0.01), r.vec = seq(0.15,0.25,0.01))
loglik.surface.accel(x, vstep.vec = seq(0,4,0.005), r.vec = seq(0.15,0.25,0.005))
x <- sim.Bokma()
## Fit a the model to the data by defining shift points.
x1<-fit.Bokma(x, minb=10)
v_1<-seq(0,1,0.01)
v_2<-seq(0,1, 0.01)
loglik.surface.Bokma(x, vstep_1.vec=v_1, vstep_2.vec=v_2, shift=11, anc=0.4280, new.opt=1.7025)
?sim.accel.decel
x <- sim.accel.decel(50)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.decel(x)
x1
x <- sim.accel.decel(30)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.decel(x)
x1
loglik.surface.decel(x, vstep.vec = seq(0,100,0.5), r.vec = seq(-0.15,0,0.001))
x1
loglik.surface.decel(x, vstep.vec = seq(50,150,0.1), r.vec = seq(-0.03,-0.01,0.001))
loglik.surface.decel(x, vstep.vec = seq(50,150,0.01), r.vec = seq(-0.03,-0.01,0.001))
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.decel.R")
loglik.surface.decel(x, vstep.vec = seq(50,150,0.01), r.vec = seq(-0.03,-0.01,0.001))
loglik.surface.decel(x, vstep.vec = seq(50,150,0.1), r.vec = seq(-0.03,-0.01,0.001))
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.decel.R")
loglik.surface.decel(x, vstep.vec = seq(50,150,0.1), r.vec = seq(-0.03,-0.01,0.001))
x <- sim.accel.decel(30)
x
x1<-opt.joint.decel(x)
x1
source("~/Dropbox/GitHub/evoTS/R/loglik.surface.decel.R")
loglik.surface.decel(x, vstep.vec = seq(50,150,0.1), r.vec = seq(-0.03,-0.01,0.001))
x1
loglik.surface.decel(x, vstep.vec = seq(50,150,0.1), r.vec = seq(-0.04,-0.01,0.001))
x <- sim.accel.decel(30)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.decel(x)
x1
xtt<-x$tt/max(x$tt)
x$tt<-x$tt/max(x$tt)
x
x1<-opt.joint.decel(x)
x1
x <- sim.accel.decel(30)
## Rescale time to unit length
x$tt<-x$tt/max(x$tt)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.decel(x)
x1
x <- sim.accel.decel(30)
x
x$tt<-x$tt/max(x$tt)
x <- sim.accel.decel(30)
x1<-opt.joint.decel(x)
x1
x$tt<-x$tt/max(x$tt)
x1<-opt.joint.decel(x)
x1
sim.accel.decel
x <- sim.accel.decel(50)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.accel(x)
x1
x <- sim.accel.decel(30, r=-0.5)
## Rescale time to unit length
##x$tt<-x$tt/max(x$tt)
## Fit a the model to the data by defining shift points.
x1<-opt.joint.decel(x)
x1
loglik.surface.decel(x, vstep.vec = seq(0, 2, 0.1), r.vec = seq(0,-1,0.01))
loglik.surface.decel(x, vstep.vec = seq(0, 2, 0.1), r.vec = seq(-1, 1, 0.01))
loglik.surface.decel(x, vstep.vec = seq(0, 5, 0.1), r.vec = seq(-1, 0, 0.01))
x <- paleoTS::sim.GRW(30)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.GRW(x)
## Compute likelihood surface
loglik.surface.GRW(x, mstep.vec= seq(0,0.3,0.01), vstep.vec = seq(0,0.3,0.01))
x <- paleoTS::sim.OU(40)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.OU(x)
##calculate half-life from model output
log(2)/x1$parameters[4]
##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[4])
##Compute likelihood surface
loglik.surface.OU(x, stat.var.vec=seq(0.001,0.5,0.01), h.vec=seq(0.01,10, 0.1))
x <- sim.OUBM(40)
## Fit a the model
x1<-paleoTS::opt.joint.OUBM(x)
x1<-paleoTS::opt.joint.OU.BM(x)
x1<-opt.joint.OU.BM(x)
log(2)/x1$parameters[4]
##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[4])
x <- sim.OUBM(40)
## Fit a the model
x1<-opt.joint.OU.BM(x)
x1
log(2)/x1$parameters[4]
x1<-opt.joint.OU.BM(1)
log(2)/x1$parameters[1]
log(2)/x1$parameters[3]
x1$parameters[2]/(2*x1$parameters[3])
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.01), h.vec=seq(0.0,1.5, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.01), h.vec=seq(0.0,2.5, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,1,0.01), h.vec=seq(0.0,5, 0.1))
loglik.surface.OUBM(x, stat.var.vec=seq(0,4,0.01), h.vec=seq(0.0,5, 0.1))
x <- paleoTS::sim.Stasis(30)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.Stasis(x)
##Compute likelihood surface
loglik.surface.stasis(x, theta.vec= seq(-0.15,0.1,0.001), omega.vec = seq(0,0.1,0.001))
x <- paleoTS::sim.GRW(30)
## Fit a the model to the data by defining shift points.
x1<-paleoTS::opt.joint.URW(x)
## Create log-likelihood surface (the example may take > 5 seconds to run)
loglik.surface.URW(x, vstep.vec = seq(0,0.3,0.001))
loglik.surface.URW(x, vstep.vec = seq(0,0.5,0.001))
document()
rm(loglik.surface.accel)
rm(loglik.surface.decel)
document()
check()
x1 <- paleoTS::sim.GRW(60)
x2 <- paleoTS::sim.GRW(60)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
yy<-x1_x2
library(paleoTS)
?plot.paleoTS
plot.paleoTS
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
lty=1
lwd=1
pch=1
x.label="Time"
y.label="Trait mean"
y_min<-min(yy$xx[,1])
y_max<-max(yy$xx[,1])
cex.axis<-1
cex.lab<-1
cex.main<-1
axes<-TRUE
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
col<-c("cornflowerblue", "orange", "red2", "forestgreen", "black", "darkblue", "tan4", "indianred", "mediumorchid", "firebrick4")
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
lines(yy$tt[,1], yy$xx[,1], col = col[1])
points(yy$tt[,2],yy$xx[,2], col=col[2], pch=pch)
lines(yy$tt[,2],yy$xx[,2], col=col[2])
SE.1<-sqrt(yy$vv[,1]/yy$nn[,1])
SE.1
?lines
SE.2<-sqrt(yy$vv[,2]/yy$nn[,2])
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
lines(yy$tt[,1], yy$xx[,1], col = col[1])
lines(yy$tt[,1], yy$xx[,1]+SE.1,col = col[1])
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
lines(yy$tt[,1], yy$xx[,1], col = col[1])
abline(v = c(yy$xx[,1]+SE.1,yy$xx[,1]-SE.1) col = col[1])
abline(v = c(yy$xx[,1]+SE.1,yy$xx[,1]-SE.1))
x <- stats::runif(12); y <- stats::rnorm(12)
i <- order(x, y); x <- x[i]; y <- y[i]
plot(x, y, main = "arrows(.) and segments(.)")
## draw arrows from point to point :
s <- seq(length(x)-1)  # one shorter than data
arrows(x[s], y[s], x[s+1], y[s+1], col= 1:3)
s <- s[-length(s)]
segments(x[s], y[s], x[s+2], y[s+2], col= 'pink')
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
plot(yy$tt[,1],yy$xx[,1],col=col[1], ylim=c(y_min,y_max),  pch=pch, xlab=x.label, ylab=y.label, cex.axis = cex.axis, cex.lab = cex.lab, cex.main = cex.main, axes = axes)
lines(yy$tt[,1], yy$xx[,1], col = col[1])
segments(x0= yy$tt[,1], y0=yy$xx[,1]+SE.1, x1=yy$tt[,1], y1=yy$xx[,1]-SE.1, col = col[1])
source("~/Dropbox/GitHub/evoTS/R/plotevoTS.multivariate.R")
x1 <- paleoTS::sim.GRW(60)
x2 <- paleoTS::sim.GRW(60)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-5, y_max=5)
source("~/Dropbox/GitHub/evoTS/R/plotevoTS.multivariate.R")
x1 <- paleoTS::sim.GRW(60, vs=1)
x2 <- paleoTS::sim.GRW(60, vs=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-5, y_max=5)
?sim.GRW
x1 <- paleoTS::?sim.GRW(60, vp=1)
x2 <- paleoTS::sim.GRW(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
x1 <- paleoTS::sim.GRW(60, vp=1)
x2 <- paleoTS::sim.GRW(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-5, y_max=5)
x1 <- paleoTS::sim.stasis(60, vp=1)
x2 <- paleoTS::sim.stasis(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
x1 <- paleoTS::sim.Stasis(60, vp=1)
x2 <- paleoTS::sim.Stasis(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-5, y_max=5)
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
source("~/Dropbox/GitHub/evoTS/R/plotevoTS.multivariate.R")
x1 <- paleoTS::sim.Stasis(60, vp=1)
x2 <- paleoTS::sim.Stasis(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1, nse=2)
x3 <- paleoTS::sim.Stasis(60, vp=1)
x1_x2<-make.multivar.evoTS(x1, x2, x3)
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
source("~/Dropbox/GitHub/evoTS/R/plotevoTS.multivariate.R")
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
## Generate two evolutionary sequences (time-sries)
x1 <- paleoTS::sim.Stasis(60, vp=1)
x2 <- paleoTS::sim.Stasis(60, vp=1)
## Make a multivariate data set
x1_x2<-make.multivar.evoTS(x1, x2)
## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
rm(plotevoTS.multivariate)
document()
check()
segments
document()
check()
install.packages("rhub")
library(rhub)
library(testthat) # Unit Testing for R
library(usethis)  # Automate Package and Project Setup
file.exists("~/.ssh/id_rsa.pub")
ssh-keygen -t rsa -C "k.l.voje@gmail.com"
git config --global user.name "klvoje"
